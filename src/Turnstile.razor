@using System.Threading
@using Soenneker.Blazor.Turnstile.Abstract
@using Microsoft.Extensions.Logging
@using Microsoft.JSInterop
@using Soenneker.Blazor.Extensions.EventCallback
@using Soenneker.Blazor.Turnstile.Options
@using Soenneker.Extensions.CancellationTokens

@inherits Soenneker.Quark.CoreCancellableComponent

@implements ITurnstile
@inject ITurnstileInterop TurnstileInterop
@inject ILogger<Turnstile> Logger

<div id="@Id" class="cf-turnstile" @attributes="Attributes" ></div>

@code {
    private DotNetObjectReference<Turnstile>? _objRef;

    private bool _shouldRender = true;
    private bool _isCreated;

    [Parameter]
    public TurnstileOptions? Options { get; set; }

    [Parameter]
    public string? SiteKey { get; set; }

    [Parameter]
    public EventCallback<string> TokenChanged { get; set; }

    [Parameter]
    public EventCallback<string> OnCallback { get; set; }

    [Parameter]
    public EventCallback<string> OnExpiredCallback { get; set; }

    [Parameter]
    public EventCallback<string> OnErrorCallback { get; set; }

    public string? WidgetId { get; private set; }
    public string? Token { get; private set; }
    private bool _initialized;
    private bool _interopInitialized;

    public Turnstile()
    {
        Id = $"turnstile-{Guid.NewGuid()}";
    }

    protected override bool ShouldRender() => _shouldRender;

    protected override void OnInitialized() => _objRef = DotNetObjectReference.Create(this);

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (!firstRender && _isCreated)
            return;

        if (!_interopInitialized)
        {
            await TurnstileInterop.Initialize(CancellationToken);
            _interopInitialized = true;
        }

        if (_isCreated || Options is { ManualCreate: true })
            return;

        await CreateWidget(CancellationToken);
    }

    private async ValueTask CreateWidget(CancellationToken cancellationToken)
    {
        try
        {
            if (Options?.ManualCreate == true)
                return;

            WidgetId = await Create(cancellationToken: cancellationToken);

            if (WidgetId != null)
                await TurnstileInterop.CreateObserver(Id, WidgetId, cancellationToken);

            _shouldRender = false;
            _isCreated = true;
        }
        catch (Exception ex)
        {
            Logger.LogError("Error during Turnstile initialization: {Exception}", ex);
        }
    }

    public async ValueTask<string?> Create(TurnstileOptions? options = null, CancellationToken cancellationToken = default)
    {
        Logger.LogDebug("Initializing Cloudflare Turnstile...");

        if (!_interopInitialized)
            throw new InvalidOperationException("Turnstile interop is not yet available. Wait until the component has rendered.");

        if (_initialized)
        {
            Logger.LogWarning("Turnstile 'Create' was called multiple times without destroying the instance first.");
            return null;
        }

        _initialized = true;

        Options ??= options ?? new TurnstileOptions();
        if (SiteKey != null)
            Options.SiteKey = SiteKey;

        if (Options.SiteKey == null)
        {
            Logger.LogError("Turnstile 'Create' requires a 'SiteKey' to be set in the options");
            return null;
        }

        var internalOptions = new InternalTurnstileOptions
        {
            CallbackEventEnabled = OnCallback.HasDelegate,
            OnErrorEventEnabled = OnErrorCallback.HasDelegate,
            OnExpiredEventEnabled = OnExpiredCallback.HasDelegate
        };

        CancellationToken linked = CancellationToken.Link(cancellationToken, out CancellationTokenSource? cts);

        using (cts)
            return await TurnstileInterop.Create(_objRef!, Id!, Options, internalOptions, linked);
    }

    public async ValueTask Reset(CancellationToken cancellationToken = default)
    {
        if (WidgetId == null)
        {
            Logger.LogError("Turnstile 'Reset' cannot be called as it appears there was an error initializing");
            return;
        }

        CancellationToken token = cancellationToken;
        CancellationTokenSource? cts = null;

        if (!token.CanBeCanceled)
            token = CancellationToken.Link(CancellationToken, out cts);

        try
        {
            await TurnstileInterop.Reset(WidgetId, token);
        }
        finally
        {
            cts?.Dispose();
        }
    }

    public async ValueTask Remove(CancellationToken cancellationToken = default)
    {
        if (WidgetId == null)
        {
            Logger.LogError("Turnstile 'Remove' cannot be called as it appears there was an error initializing");
            return;
        }

        CancellationToken token = cancellationToken;
        CancellationTokenSource? cts = null;

        if (!token.CanBeCanceled)
            token = CancellationToken.Link(CancellationToken, out cts);

        try
        {
            await TurnstileInterop.Remove(WidgetId, token);
        }
        finally
        {
            cts?.Dispose();
        }
    }


    [JSInvokable]
    public Task Callback(string token)
    {
        Token = token;
        return NotifyTokenChangedAsync(token);
    }

    [JSInvokable]
    public async Task ErrorCallback(string message)
    {
        Logger.LogError("Turnstile error: {Message}", message);
        Token = null;
        await NotifyTokenChangedAsync(Token);
        await OnErrorCallback.InvokeIfHasDelegate(message);
    }

    [JSInvokable]
    public async Task ExpiredCallback(string message)
    {
        Logger.LogError("Turnstile token has expired");
        Token = null;
        await NotifyTokenChangedAsync(Token);
        await OnExpiredCallback.InvokeIfHasDelegate(message);
    }

    private async Task NotifyTokenChangedAsync(string? token)
    {
        await TokenChanged.InvokeIfHasDelegate(token);
        await OnCallback.InvokeIfHasDelegate(token);
    }

    public override async ValueTask DisposeAsync()
    {
        await base.DisposeAsync();

        WidgetId = null;

        _initialized = false;
        _isCreated = false;
        _interopInitialized = false;

        _objRef?.Dispose();
    }

}
